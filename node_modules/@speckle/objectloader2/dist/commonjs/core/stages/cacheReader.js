"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheReader = void 0;
const batchingQueue_js_1 = __importDefault(require("../../queues/batchingQueue.js"));
class CacheReader {
    #database;
    #defermentManager;
    #logger;
    #options;
    #readQueue;
    #foundQueue;
    #notFoundQueue;
    constructor(database, defermentManager, logger, options) {
        this.#database = database;
        this.#defermentManager = defermentManager;
        this.#logger = logger;
        this.#options = options;
    }
    initializeQueue(foundQueue, notFoundQueue) {
        this.#foundQueue = foundQueue;
        this.#notFoundQueue = notFoundQueue;
    }
    getObject(params) {
        const [p, b] = this.#defermentManager.defer({ id: params.id });
        if (!b) {
            this.requestItem(params.id);
        }
        return p;
    }
    #createReadQueue() {
        if (!this.#readQueue) {
            this.#readQueue = new batchingQueue_js_1.default({
                batchSize: this.#options.maxCacheReadSize,
                maxWaitTime: this.#options.maxCacheBatchReadWait,
                processFunction: this.#processBatch
            });
        }
    }
    requestItem(id) {
        this.#createReadQueue();
        if (!this.#readQueue?.get(id)) {
            this.#readQueue?.add(id, id);
        }
    }
    requestAll(keys) {
        this.#createReadQueue();
        this.#readQueue?.addAll(keys, keys);
    }
    #processBatch = async (batch) => {
        const start = performance.now();
        const items = await this.#database.getAll(batch);
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item) {
                this.#foundQueue?.add(item);
                this.#defermentManager.undefer(item, (id) => this.requestItem(id));
            }
            else {
                this.#notFoundQueue?.add(batch[i]);
            }
        }
        this.#logger(`readBatch: batch ${batch.length}, time ${performance.now() - start} ms left ${this.#readQueue?.count()}`);
    };
    disposeAsync() {
        return this.#readQueue?.disposeAsync() || Promise.resolve();
    }
}
exports.CacheReader = CacheReader;
//# sourceMappingURL=cacheReader.js.map