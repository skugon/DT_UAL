"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheWriter = void 0;
const batchingQueue_js_1 = __importDefault(require("../../queues/batchingQueue.js"));
class CacheWriter {
    #writeQueue;
    #database;
    #deferment;
    #requestItem;
    #logger;
    #options;
    #disposed = false;
    constructor(database, logger, deferment, options, requestItem) {
        this.#database = database;
        this.#options = options;
        this.#logger = logger;
        this.#deferment = deferment;
        this.#requestItem = requestItem;
    }
    add(item) {
        if (!this.#writeQueue) {
            this.#writeQueue = new batchingQueue_js_1.default({
                batchSize: this.#options.maxCacheWriteSize,
                maxWaitTime: this.#options.maxCacheBatchWriteWait,
                processFunction: async (batch) => {
                    await this.writeAll(batch);
                }
            });
        }
        this.#writeQueue.add(item.baseId, item);
        this.#deferment.undefer(item, this.#requestItem);
    }
    async writeAll(items) {
        const start = performance.now();
        await this.#database.putAll(items);
        this.#logger(`writeBatch: wrote ${items.length}, time ${performance.now() - start} ms left ${this.#writeQueue?.count()}`);
    }
    async disposeAsync() {
        this.#disposed = true;
        await this.#writeQueue?.disposeAsync();
    }
    get isDisposed() {
        return this.#disposed;
    }
}
exports.CacheWriter = CacheWriter;
//# sourceMappingURL=cacheWriter.js.map