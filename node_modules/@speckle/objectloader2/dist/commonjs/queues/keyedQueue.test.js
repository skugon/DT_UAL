"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const keyedQueue_js_1 = __importDefault(require("./keyedQueue.js"));
(0, vitest_1.describe)('KeyedQueue', () => {
    let queue;
    (0, vitest_1.beforeEach)(() => {
        queue = new keyedQueue_js_1.default();
    });
    (0, vitest_1.describe)('enqueue', () => {
        (0, vitest_1.it)('should add a key-value pair to the queue', () => {
            const result = queue.enqueue('key1', 1);
            (0, vitest_1.expect)(result).toBe(true);
            (0, vitest_1.expect)(queue.size).toBe(1);
            (0, vitest_1.expect)(queue.get('key1')).toBe(1);
        });
        (0, vitest_1.it)('should return false when trying to add a key that already exists', () => {
            queue.enqueue('key1', 1);
            const result = queue.enqueue('key1', 2);
            (0, vitest_1.expect)(result).toBe(false);
            (0, vitest_1.expect)(queue.size).toBe(1);
            (0, vitest_1.expect)(queue.get('key1')).toBe(1); // Value should not be updated
        });
    });
    (0, vitest_1.describe)('enqueueAll', () => {
        (0, vitest_1.it)('should add multiple key-value pairs to the queue', () => {
            const keys = ['key1', 'key2', 'key3'];
            const values = [1, 2, 3];
            const count = queue.enqueueAll(keys, values);
            (0, vitest_1.expect)(count).toBe(3);
            (0, vitest_1.expect)(queue.size).toBe(3);
            (0, vitest_1.expect)(queue.get('key1')).toBe(1);
            (0, vitest_1.expect)(queue.get('key2')).toBe(2);
            (0, vitest_1.expect)(queue.get('key3')).toBe(3);
        });
        (0, vitest_1.it)('should skip keys that already exist and return the count of added items', () => {
            queue.enqueue('key1', 1);
            const keys = ['key1', 'key2', 'key3'];
            const values = [10, 2, 3];
            const count = queue.enqueueAll(keys, values);
            (0, vitest_1.expect)(count).toBe(2);
            (0, vitest_1.expect)(queue.size).toBe(3);
            (0, vitest_1.expect)(queue.get('key1')).toBe(1); // Original value preserved
            (0, vitest_1.expect)(queue.get('key2')).toBe(2);
            (0, vitest_1.expect)(queue.get('key3')).toBe(3);
        });
    });
    (0, vitest_1.describe)('get', () => {
        (0, vitest_1.it)('should return the value for a given key', () => {
            queue.enqueue('key1', 1);
            (0, vitest_1.expect)(queue.get('key1')).toBe(1);
        });
        (0, vitest_1.it)('should return undefined for a non-existent key', () => {
            (0, vitest_1.expect)(queue.get('nonexistent')).toBeUndefined();
        });
    });
    (0, vitest_1.describe)('has', () => {
        (0, vitest_1.it)('should return true if the key exists', () => {
            queue.enqueue('key1', 1);
            (0, vitest_1.expect)(queue.has('key1')).toBe(true);
        });
        (0, vitest_1.it)('should return false if the key does not exist', () => {
            (0, vitest_1.expect)(queue.has('nonexistent')).toBe(false);
        });
    });
    (0, vitest_1.describe)('size', () => {
        (0, vitest_1.it)('should return the number of items in the queue', () => {
            (0, vitest_1.expect)(queue.size).toBe(0);
            queue.enqueue('key1', 1);
            (0, vitest_1.expect)(queue.size).toBe(1);
            queue.enqueue('key2', 2);
            (0, vitest_1.expect)(queue.size).toBe(2);
        });
    });
    (0, vitest_1.describe)('spliceValues', () => {
        (0, vitest_1.it)('should remove and return values from the queue', () => {
            queue.enqueue('key1', 1);
            queue.enqueue('key2', 2);
            queue.enqueue('key3', 3);
            queue.enqueue('key4', 4);
            const result = queue.spliceValues(1, 2);
            (0, vitest_1.expect)(result).toEqual([2, 3]);
            (0, vitest_1.expect)(queue.size).toBe(2);
            (0, vitest_1.expect)(queue.has('key1')).toBe(true);
            (0, vitest_1.expect)(queue.has('key2')).toBe(false);
            (0, vitest_1.expect)(queue.has('key3')).toBe(false);
            (0, vitest_1.expect)(queue.has('key4')).toBe(true);
        });
        (0, vitest_1.it)('should handle splicing at the beginning of the queue', () => {
            queue.enqueue('key1', 1);
            queue.enqueue('key2', 2);
            const result = queue.spliceValues(0, 1);
            (0, vitest_1.expect)(result).toEqual([1]);
            (0, vitest_1.expect)(queue.size).toBe(1);
            (0, vitest_1.expect)(queue.has('key1')).toBe(false);
            (0, vitest_1.expect)(queue.has('key2')).toBe(true);
        });
        (0, vitest_1.it)('should handle splicing at the end of the queue', () => {
            queue.enqueue('key1', 1);
            queue.enqueue('key2', 2);
            const result = queue.spliceValues(1, 1);
            (0, vitest_1.expect)(result).toEqual([2]);
            (0, vitest_1.expect)(queue.size).toBe(1);
            (0, vitest_1.expect)(queue.has('key1')).toBe(true);
            (0, vitest_1.expect)(queue.has('key2')).toBe(false);
        });
        (0, vitest_1.it)('should return an empty array when deleting zero elements', () => {
            queue.enqueue('key1', 1);
            const result = queue.spliceValues(0, 0);
            (0, vitest_1.expect)(result).toEqual([]);
            (0, vitest_1.expect)(queue.size).toBe(1);
        });
    });
});
//# sourceMappingURL=keyedQueue.test.js.map