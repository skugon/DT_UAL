"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const batchingQueue_js_1 = __importDefault(require("./batchingQueue.js"));
(0, vitest_1.describe)('BatchingQueue disposal', () => {
    (0, vitest_1.test)('should drain the queue on dispose', async () => {
        const processFunction = vitest_1.vi.fn().mockResolvedValue(undefined);
        const queue = new batchingQueue_js_1.default({
            batchSize: 5,
            maxWaitTime: 1000,
            processFunction
        });
        const items = Array.from({ length: 3 }, (_, i) => ({ id: `item-${i}` }));
        items.forEach((item) => queue.add(item.id, item));
        (0, vitest_1.expect)(queue.count()).toBe(3);
        await queue.disposeAsync();
        (0, vitest_1.expect)(processFunction).toHaveBeenCalled();
        (0, vitest_1.expect)(queue.count()).toBe(0);
        (0, vitest_1.expect)(queue.isDisposed()).toBe(true);
    });
    (0, vitest_1.test)('should wait for processing to finish before disposing', async () => {
        let resolveProcess = () => { };
        const processPromise = new Promise((resolve) => {
            resolveProcess = resolve;
        });
        const processFunction = vitest_1.vi.fn().mockImplementation(() => processPromise);
        const queue = new batchingQueue_js_1.default({
            batchSize: 2,
            maxWaitTime: 100,
            processFunction
        });
        const items1 = [{ id: 'item-1' }, { id: 'item-2' }];
        items1.forEach((item) => queue.add(item.id, item));
        // First batch is processing
        (0, vitest_1.expect)(processFunction).toHaveBeenCalledWith(items1);
        const items2 = [{ id: 'item-3' }];
        items2.forEach((item) => queue.add(item.id, item));
        const disposePromise = queue.disposeAsync();
        // Queue should be disposed now, but processing is still ongoing
        (0, vitest_1.expect)(queue.isDisposed()).toBe(true);
        resolveProcess();
        await disposePromise;
        (0, vitest_1.expect)(queue.count()).toBe(0);
        (0, vitest_1.expect)(queue.isDisposed()).toBe(true);
    });
    (0, vitest_1.test)('adding items after dispose should do nothing', async () => {
        const processFunction = vitest_1.vi.fn().mockResolvedValue(undefined);
        const queue = new batchingQueue_js_1.default({
            batchSize: 5,
            maxWaitTime: 1000,
            processFunction
        });
        await queue.disposeAsync();
        queue.add('key1', 'item1');
        (0, vitest_1.expect)(queue.count()).toBe(0);
        (0, vitest_1.expect)(processFunction).not.toHaveBeenCalled();
    });
});
//# sourceMappingURL=batchingQueue.dispose.test.js.map