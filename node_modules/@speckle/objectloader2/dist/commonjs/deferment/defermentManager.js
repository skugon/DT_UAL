"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefermentManager = exports.MemoryOnlyDeferment = void 0;
const deferredBase_js_1 = require("./deferredBase.js");
const MemoryCache_js_1 = require("./MemoryCache.js");
class MemoryOnlyDeferment {
    items;
    constructor(items) {
        this.items = items;
    }
    defer(params) {
        const item = this.items.get(params.id);
        if (item) {
            return [Promise.resolve(item), true];
        }
        return [Promise.reject(new Error('Not found in cache: ' + params.id)), false];
    }
    undefer() {
        //no-op
    }
    dispose() {
        //no-op
    }
}
exports.MemoryOnlyDeferment = MemoryOnlyDeferment;
class DefermentManager {
    outstanding = new Map();
    logger;
    disposed = false;
    cache;
    constructor(logger, cache) {
        this.logger = logger;
        this.cache =
            cache ||
                new MemoryCache_js_1.MemoryCache({
                    maxSizeInMb: 500, // 500 MB
                    ttlms: 5_000 // 5 seconds
                }, logger);
    }
    defer(params) {
        if (this.disposed)
            throw new Error('DefermentManager is disposed');
        const item = this.cache.get(params.id);
        if (item) {
            return [Promise.resolve(item.base), true];
        }
        const deferredBase = this.outstanding.get(params.id);
        if (deferredBase) {
            return [deferredBase.getPromise(), true];
        }
        const notYetFound = new deferredBase_js_1.DeferredBase(params.id);
        this.outstanding.set(params.id, notYetFound);
        return [notYetFound.getPromise(), false];
    }
    undefer(item, requestItem) {
        if (this.disposed)
            throw new Error('DefermentManager is disposed');
        const base = item.base;
        if (!base) {
            this.logger('undefer called with no base', item);
            return;
        }
        this.cache.add(item, (id) => {
            if (!this.outstanding.has(id)) {
                requestItem(id);
            }
        });
        //order matters here with found before undefer
        const deferredBase = this.outstanding.get(item.baseId);
        if (deferredBase) {
            deferredBase.found(base);
            this.outstanding.delete(item.baseId);
        }
    }
    dispose() {
        if (this.disposed)
            return;
        this.disposed = true;
        this.logger('cleared deferments, left', this.outstanding.size);
        this.outstanding.clear();
        this.cache.dispose();
    }
}
exports.DefermentManager = DefermentManager;
//# sourceMappingURL=defermentManager.js.map