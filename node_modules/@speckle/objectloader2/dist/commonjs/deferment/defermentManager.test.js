"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const defermentManager_js_1 = require("./defermentManager.js");
(0, vitest_1.describe)('DefermentManager', () => {
    (0, vitest_1.it)('should be created', () => {
        const mockLogger = vitest_1.vi.fn();
        const mockCache = {
            get: vitest_1.vi.fn(),
            add: vitest_1.vi.fn(),
            dispose: vitest_1.vi.fn()
        };
        const defermentManager = new defermentManager_js_1.DefermentManager(mockLogger, mockCache);
        (0, vitest_1.expect)(defermentManager).toBeDefined();
    });
    (0, vitest_1.describe)('defer', () => {
        (0, vitest_1.it)('should return a resolved promise if item is in cache', async () => {
            const mockLogger = vitest_1.vi.fn();
            const get = vitest_1.vi.fn();
            const add = vitest_1.vi.fn();
            const mockCache = {
                get,
                add
            };
            const defermentManager = new defermentManager_js_1.DefermentManager(mockLogger, mockCache);
            const item = {
                // eslint-disable-next-line camelcase
                base: { id: 'testId', speckle_type: 'Base' },
                baseId: 'testId'
            };
            get.mockReturnValue(item);
            const [promise, wasInCache] = defermentManager.defer({ id: 'testId' });
            const result = await promise;
            (0, vitest_1.expect)(wasInCache).toBe(true);
            (0, vitest_1.expect)(result).toEqual(item.base);
            (0, vitest_1.expect)(get).toHaveBeenCalledWith('testId');
        });
        (0, vitest_1.it)('should return the same promise if item is already outstanding', () => {
            const mockLogger = vitest_1.vi.fn();
            const get = vitest_1.vi.fn();
            const add = vitest_1.vi.fn();
            const mockCache = {
                get,
                add
            };
            const defermentManager = new defermentManager_js_1.DefermentManager(mockLogger, mockCache);
            const [promise1, wasInCache1] = defermentManager.defer({ id: 'testId' });
            const [promise2, wasInCache2] = defermentManager.defer({ id: 'testId' });
            (0, vitest_1.expect)(wasInCache1).toBe(false);
            (0, vitest_1.expect)(wasInCache2).toBe(true);
            (0, vitest_1.expect)(promise1).toBe(promise2);
        });
        (0, vitest_1.it)('should create a new deferred base if not in cache and not outstanding', () => {
            const mockLogger = vitest_1.vi.fn();
            const get = vitest_1.vi.fn();
            const add = vitest_1.vi.fn();
            const mockCache = {
                get,
                add
            };
            const defermentManager = new defermentManager_js_1.DefermentManager(mockLogger, mockCache);
            const [promise, wasInCache] = defermentManager.defer({ id: 'testId' });
            (0, vitest_1.expect)(wasInCache).toBe(false);
            (0, vitest_1.expect)(promise).toBeInstanceOf(Promise);
        });
        (0, vitest_1.it)('should throw if disposed', () => {
            const mockLogger = vitest_1.vi.fn();
            const get = vitest_1.vi.fn();
            const add = vitest_1.vi.fn();
            const mockCache = {
                get,
                add,
                dispose: vitest_1.vi.fn()
            };
            const defermentManager = new defermentManager_js_1.DefermentManager(mockLogger, mockCache);
            defermentManager.dispose();
            (0, vitest_1.expect)(() => defermentManager.defer({ id: 'testId' })).toThrow('DefermentManager is disposed');
        });
    });
    (0, vitest_1.describe)('undefer', () => {
        (0, vitest_1.it)('should resolve the promise when an outstanding item is found', async () => {
            const mockLogger = vitest_1.vi.fn();
            const get = vitest_1.vi.fn();
            const add = vitest_1.vi.fn();
            const mockCache = {
                get,
                add
            };
            const defermentManager = new defermentManager_js_1.DefermentManager(mockLogger, mockCache);
            const requestItem = vitest_1.vi.fn();
            const [promise] = defermentManager.defer({ id: 'testId' });
            const item = {
                // eslint-disable-next-line camelcase
                base: { id: 'testId', speckle_type: 'Base' },
                baseId: 'testId'
            };
            defermentManager.undefer(item, requestItem);
            const result = await promise;
            (0, vitest_1.expect)(result).toEqual(item.base);
        });
        (0, vitest_1.it)('should log an error if item has no base', () => {
            const mockLogger = vitest_1.vi.fn();
            const get = vitest_1.vi.fn();
            const add = vitest_1.vi.fn();
            const mockCache = {
                get,
                add
            };
            const defermentManager = new defermentManager_js_1.DefermentManager(mockLogger, mockCache);
            const requestItem = vitest_1.vi.fn();
            const item = { baseId: 'testId' };
            defermentManager.undefer(item, requestItem);
            (0, vitest_1.expect)(mockLogger).toHaveBeenCalledWith('undefer called with no base', item);
        });
        (0, vitest_1.it)('should add to cache and request item if not outstanding', () => {
            const mockLogger = vitest_1.vi.fn();
            const get = vitest_1.vi.fn();
            const add = vitest_1.vi.fn();
            const mockCache = {
                get,
                add
            };
            const defermentManager = new defermentManager_js_1.DefermentManager(mockLogger, mockCache);
            const requestItem = vitest_1.vi.fn();
            const item = {
                // eslint-disable-next-line camelcase
                base: { id: 'testId', speckle_type: 'Base' },
                baseId: 'testId'
            };
            add.mockImplementation((_item, getDependencies) => {
                if (getDependencies)
                    getDependencies('testId');
            });
            defermentManager.undefer(item, requestItem);
            (0, vitest_1.expect)(add).toHaveBeenCalledWith(item, vitest_1.expect.any(Function));
            (0, vitest_1.expect)(requestItem).toHaveBeenCalledWith('testId');
        });
        (0, vitest_1.it)('should throw if disposed', () => {
            const mockLogger = vitest_1.vi.fn();
            const get = vitest_1.vi.fn();
            const add = vitest_1.vi.fn();
            const mockCache = {
                get,
                add,
                dispose: vitest_1.vi.fn()
            };
            const defermentManager = new defermentManager_js_1.DefermentManager(mockLogger, mockCache);
            const requestItem = vitest_1.vi.fn();
            defermentManager.dispose();
            const item = {
                // eslint-disable-next-line camelcase
                base: { id: 'testId', speckle_type: 'Base' },
                baseId: 'testId'
            };
            (0, vitest_1.expect)(() => defermentManager.undefer(item, requestItem)).toThrow('DefermentManager is disposed');
        });
    });
    (0, vitest_1.describe)('dispose', () => {
        (0, vitest_1.it)('should clear all outstanding deferments', () => {
            const mockLogger = vitest_1.vi.fn();
            const get = vitest_1.vi.fn();
            const add = vitest_1.vi.fn();
            const mockCache = {
                get,
                add,
                dispose: vitest_1.vi.fn()
            };
            const defermentManager = new defermentManager_js_1.DefermentManager(mockLogger, mockCache);
            void defermentManager.defer({ id: 'testId' });
            defermentManager.dispose();
            // @ts-expect-error - accessing private property for testing
            (0, vitest_1.expect)(defermentManager.outstanding.size).toBe(0);
        });
        (0, vitest_1.it)('should not do anything if already disposed', () => {
            const mockLogger = vitest_1.vi.fn();
            const get = vitest_1.vi.fn();
            const add = vitest_1.vi.fn();
            const mockCache = {
                get,
                add,
                dispose: vitest_1.vi.fn()
            };
            const defermentManager = new defermentManager_js_1.DefermentManager(mockLogger, mockCache);
            defermentManager.dispose();
            // @ts-expect-error - accessing private property for testing
            const outstanding = defermentManager.outstanding;
            const clearSpy = vitest_1.vi.spyOn(outstanding, 'clear');
            defermentManager.dispose();
            (0, vitest_1.expect)(clearSpy).not.toHaveBeenCalled();
        });
    });
});
//# sourceMappingURL=defermentManager.test.js.map