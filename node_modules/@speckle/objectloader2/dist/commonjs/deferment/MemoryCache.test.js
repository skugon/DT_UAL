"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const MemoryCache_js_1 = require("./MemoryCache.js");
const logger = () => {
    // console.log(message, ...optionalParams)
};
const defaultOptions = {
    maxSizeInMb: 10,
    ttlms: 1000
};
const createItem = (id, size, referencedIds = []) => {
    const base = {
        id,
        // eslint-disable-next-line camelcase
        speckle_type: 'Base'
    };
    if (referencedIds.length > 0) {
        base.data = referencedIds.map((referencedId) => ({
            // eslint-disable-next-line camelcase
            speckle_type: 'reference',
            referencedId
        }));
    }
    return {
        baseId: id,
        base,
        size
    };
};
(0, vitest_1.describe)('MemoryCacheItem', () => {
    (0, vitest_1.it)('should correctly determine if it is expired', () => {
        const item = createItem('1', 100);
        const now = Date.now();
        const cacheItem = new MemoryCache_js_1.MemoryCacheItem(item, now + 1000);
        (0, vitest_1.expect)(cacheItem.isExpired(now + 500)).toBe(false);
        (0, vitest_1.expect)(cacheItem.isExpired(now + 1500)).toBe(true);
    });
    (0, vitest_1.it)('should update its access time', () => {
        const item = createItem('1', 100);
        const now = Date.now();
        const cacheItem = new MemoryCache_js_1.MemoryCacheItem(item, now + 1000);
        cacheItem.setAccess(now + 500, 1000);
        (0, vitest_1.expect)(cacheItem.isExpired(now + 1000)).toBe(false);
        (0, vitest_1.expect)(cacheItem.isExpired(now + 1600)).toBe(true);
    });
    (0, vitest_1.it)('should return the correct item', () => {
        const item = createItem('1', 100);
        const cacheItem = new MemoryCache_js_1.MemoryCacheItem(item, Date.now() + 1000);
        (0, vitest_1.expect)(cacheItem.getItem()).toEqual(item);
    });
    (0, vitest_1.it)('should be done if expired', () => {
        const item = createItem('1', 100);
        const now = Date.now();
        const cacheItem = new MemoryCache_js_1.MemoryCacheItem(item, now + 1000);
        (0, vitest_1.expect)(cacheItem.done(now + 1500)).toBe(true);
        (0, vitest_1.expect)(cacheItem.done(now + 500)).toBe(false);
    });
});
(0, vitest_1.describe)('MemoryCache', () => {
    (0, vitest_1.beforeEach)(() => {
        vitest_1.vi.useFakeTimers();
    });
    (0, vitest_1.afterEach)(() => {
        vitest_1.vi.useRealTimers();
    });
    (0, vitest_1.it)('should add and get an item', () => {
        const cache = new MemoryCache_js_1.MemoryCache(defaultOptions, logger);
        const item = createItem('1', 100);
        const requestItem = vitest_1.vi.fn();
        cache.add(item, requestItem);
        const retrieved = cache.get('1');
        (0, vitest_1.expect)(retrieved).toEqual(item);
        (0, vitest_1.expect)(requestItem).not.toHaveBeenCalled();
    });
    (0, vitest_1.it)('should update expiry on get', () => {
        const cache = new MemoryCache_js_1.MemoryCache({ ...defaultOptions, ttlms: 100 }, logger);
        const item = createItem('1', 100);
        cache.add(item, vitest_1.vi.fn());
        vitest_1.vi.advanceTimersByTime(50);
        const retrieved = cache.get('1');
        (0, vitest_1.expect)(retrieved).toBeDefined();
        vitest_1.vi.advanceTimersByTime(80);
        const retrievedAgain = cache.get('1');
        (0, vitest_1.expect)(retrievedAgain).toBeDefined();
    });
    (0, vitest_1.it)('should return undefined for non-existent item', () => {
        const cache = new MemoryCache_js_1.MemoryCache(defaultOptions, logger);
        (0, vitest_1.expect)(cache.get('non-existent')).toBeUndefined();
    });
    (0, vitest_1.it)('should scan for references and request missing ones', () => {
        const cache = new MemoryCache_js_1.MemoryCache(defaultOptions, logger);
        const requestItem = vitest_1.vi.fn();
        const item = createItem('1', 100, ['2', '3']);
        cache.add(createItem('3', 50), vitest_1.vi.fn()); // pre-cache one of the references
        cache.scanForReferences(item.base, requestItem);
        (0, vitest_1.expect)(requestItem).toHaveBeenCalledTimes(1);
        (0, vitest_1.expect)(requestItem).toHaveBeenCalledWith('2');
        (0, vitest_1.expect)(requestItem).not.toHaveBeenCalledWith('3');
    });
    (0, vitest_1.it)('should clean up expired items when size exceeds max', () => {
        const options = { maxSizeInMb: 0, ttlms: 100 }; // 100 bytes
        const cache = new MemoryCache_js_1.MemoryCache(options, logger);
        const requestItem = vitest_1.vi.fn();
        const item1 = createItem('1', 60);
        const item2 = createItem('2', 60);
        const now = 1;
        cache.add(item1, requestItem, now - 200);
        cache.cleanCache(now);
        cache.add(item2, requestItem, now + 100);
        (0, vitest_1.expect)(cache.get('1')).toBeUndefined();
        (0, vitest_1.expect)(cache.get('2')).toBeDefined();
    });
    (0, vitest_1.it)('should not clean up expired items if they have references', () => {
        const options = { maxSizeInMb: 0.0001, ttlms: 100 }; // 100 bytes
        const cache = new MemoryCache_js_1.MemoryCache(options, logger);
        const requestItem = vitest_1.vi.fn();
        const item1 = createItem('1', 60);
        const item2 = createItem('2', 60, ['1']);
        cache.add(item1, requestItem);
        vitest_1.vi.advanceTimersByTime(110); // item1 expires
        cache.add(item2, requestItem); // item2 adds a reference to item1
        vitest_1.vi.advanceTimersByTime(100);
        (0, vitest_1.expect)(cache.get('1')).toBeDefined();
        (0, vitest_1.expect)(cache.get('2')).toBeDefined();
    });
    (0, vitest_1.it)('compareMaybeBasesByReferences should sort correctly', () => {
        const cache = new MemoryCache_js_1.MemoryCache(defaultOptions, logger);
        const requestItem = vitest_1.vi.fn();
        const item1 = createItem('1', 10);
        const item2 = createItem('2', 10);
        const item3 = createItem('3', 10, ['1', '2']);
        const item4 = createItem('4', 10, ['2']);
        cache.add(item1, requestItem);
        cache.add(item2, requestItem);
        cache.add(item3, requestItem);
        cache.add(item4, requestItem);
        (0, vitest_1.expect)(cache.compareMaybeBasesByReferences('1', '2')).toBe(-1);
        (0, vitest_1.expect)(cache.compareMaybeBasesByReferences('2', '1')).toBe(1);
        (0, vitest_1.expect)(cache.compareMaybeBasesByReferences('1', '1')).toBe(0);
        (0, vitest_1.expect)(cache.compareMaybeBasesByReferences('1', '5')).toBe(1);
        (0, vitest_1.expect)(cache.compareMaybeBasesByReferences('5', '1')).toBe(-1);
        (0, vitest_1.expect)(cache.compareMaybeBasesByReferences('5', '6')).toBe(0);
    });
    (0, vitest_1.it)('should throw when used after dispose', () => {
        const cache = new MemoryCache_js_1.MemoryCache(defaultOptions, logger);
        cache.dispose();
        const item = createItem('1', 100);
        (0, vitest_1.expect)(() => cache.add(item, vitest_1.vi.fn())).toThrow('MemoryCache is disposed');
        (0, vitest_1.expect)(() => cache.get('1')).toThrow('MemoryCache is disposed');
    });
});
//# sourceMappingURL=MemoryCache.test.js.map