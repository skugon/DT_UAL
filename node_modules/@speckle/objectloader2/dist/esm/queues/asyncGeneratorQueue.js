export default class AsyncGeneratorQueue {
    #buffer = [];
    #resolveQueue = [];
    #finished = false;
    add(value) {
        if (this.#resolveQueue.length > 0) {
            // If there's a pending consumer, resolve immediately
            const resolve = this.#resolveQueue.shift();
            resolve(value);
        }
        else {
            // Otherwise, add to the buffer
            this.#buffer.push(value);
        }
    }
    async *consume() {
        while (!this.#finished ||
            this.#resolveQueue.length > 0 ||
            this.#buffer.length > 0) {
            if (this.#buffer.length > 0) {
                yield this.#buffer.shift(); // Yield available values
            }
            else {
                yield await new Promise((resolve) => this.#resolveQueue.push(resolve));
            }
        }
    }
    disposeAsync() {
        this.#finished = true;
        return Promise.resolve();
    }
}
//# sourceMappingURL=asyncGeneratorQueue.js.map