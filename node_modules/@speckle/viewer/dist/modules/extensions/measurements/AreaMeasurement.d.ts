import { Box3, Camera, Plane, Raycaster, Vector2, Vector3, type Intersection } from 'three';
import { Measurement } from './Measurement.js';
import { ExtendedMeshIntersection } from '../../objects/SpeckleRaycaster.js';
import { MeasurementData, MeasurementType } from '@speckle/shared/viewer/state';
export declare class AreaMeasurement extends Measurement {
    /** We store all gizmos here */
    private pointGizmos;
    /** This stores the last touched point position and normal */
    private surfacePoint;
    private surfaceNormal;
    /** The plane params defined by the first placed point
     *  When serialized they will go in the measurements startPoint and startNormal
     */
    private planeOrigin;
    private planeNormal;
    /** The location of the area text label */
    private labelPoint;
    /** Various point list. A bit exhaustive, but safer */
    private pointIndex;
    /** The selected points in 3D space */
    private points;
    /** The selected points projected on the measurement plane */
    private measuredPoints;
    /** The points defining the fill polygon. Also projected on the measurement plane */
    private polygonPoints;
    private fillPolygon;
    private snapDistance;
    set isVisible(value: boolean);
    get bounds(): Box3;
    get measurementType(): MeasurementType;
    constructor();
    /** Frame */
    frameUpdate(camera: Camera, size: Vector2, bounds: Box3): void;
    /** Called whenver the last touched location updates */
    locationUpdated(point: Vector3, normal: Vector3): void;
    /** Called whenver a location is selected for measuring*/
    locationSelected(): void;
    /** Adds a point to the area measurement */
    addPoint(point: Vector3): number;
    /** Removes point from the measurement */
    removePoint(): number;
    /** Auto completes the measurement by joining with the first point */
    autoFinish(): void;
    /** Area measurement's custom snap function. We snap to the first point by design */
    snap(ndcPoint: Vector2, _intersection: ExtendedMeshIntersection, outPoint: Vector3, outNormal: Vector3): boolean;
    /** Updates the gizmo components based on it's state and values */
    update(): Promise<void>;
    /** Updates the area label location using the polyong's pole of innaccessibility
     *  We do this to avoid having the label outside of the polygin in case of concave polygons
     *  It works great for concave polygons, but not so great for convex regular ones
     */
    private updateLabelLocation;
    /** Updates the measured polygon's geometry */
    private updateFillPolygon;
    /** Measurement's custom picking. We don't test the polygon when casting */
    raycast(raycaster: Raycaster, intersects: Array<Intersection>): void;
    highlight(value: boolean): void;
    updateClippingPlanes(planes: Plane[]): void;
    /** Had to make my own. Three's Hesse normal form trips me up */
    private projectOnPlane;
    /** Selects the vector components to use based on the measurement plane.
     *  Don't really like it, but it works
     */
    private chooseProjectionAxes;
    /** Area calculation */
    private shoelaceArea;
    private shoelaceArea3D;
    toMeasurementData(): MeasurementData;
    fromMeasurementData(data: MeasurementData): void;
}
