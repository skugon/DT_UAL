import { Euler, OrthographicCamera, PerspectiveCamera, Sphere, Vector2, Vector3 } from 'three';
import { Damper } from '../../utils/Damper.js';
import { SpeckleControls } from './SpeckleControls.js';
import { World } from '../../World.js';
import { AngleDamper } from '../../utils/AngleDamper.js';
type MoveType = 'forward' | 'back' | 'left' | 'right' | 'up' | 'down';
export interface FlyControlsOptions {
    [name: string]: unknown;
    enableLook?: boolean;
    lookSpeed?: number;
    moveSpeed?: number;
    damperDecay?: number;
    relativeUpDown?: boolean;
}
declare class FlyControls extends SpeckleControls {
    protected _options: Required<FlyControlsOptions>;
    protected _targetCamera: PerspectiveCamera | OrthographicCamera;
    protected container: HTMLElement;
    protected velocity: Vector3;
    protected euler: Euler;
    protected position: Vector3;
    protected goalEuler: Euler;
    protected goalPosition: Vector3;
    protected keyMap: Record<MoveType, boolean>;
    protected contextMenuTriggered: boolean;
    protected eulerXDamper: AngleDamper;
    protected eulerYDamper: AngleDamper;
    protected eulerZDamper: AngleDamper;
    protected positionXDamper: Damper;
    protected positionYDamper: Damper;
    protected positionZDamper: Damper;
    protected _lastTick: number;
    protected _enabled: boolean;
    private _basisTransform;
    private _basisTransformInv;
    protected _minDist: number;
    private world;
    get enabled(): boolean;
    set enabled(value: boolean);
    get options(): FlyControlsOptions;
    set options(value: FlyControlsOptions);
    set targetCamera(target: PerspectiveCamera | OrthographicCamera);
    get up(): Vector3;
    set up(value: Vector3);
    set minDist(value: number);
    constructor(camera: PerspectiveCamera | OrthographicCamera, container: HTMLElement, world: World, options: Required<FlyControlsOptions>);
    isStationary(): boolean;
    update(delta?: number): boolean;
    protected updatePositionRotation(delta: number): void;
    jumpToGoal(): void;
    fitToSphere(sphere: Sphere): void;
    /** The input position and target will be in a basis with (0,0,1) as up */
    fromPositionAndTarget(position: Vector3, target: Vector3): void;
    /** The returned vector needs to be in a basis with (0,0,1) as up */
    getTarget(): Vector3;
    /** The returned vector needs to be in a basis with (0,0,1) as up */
    getPosition(): Vector3;
    /**
     * Gets the current goal position
     */
    getCurrentPosition(): Vector3;
    /**
     * Gets the point in model coordinates the model should orbit/pivot around.
     */
    getCurrentTarget(): Vector3;
    /**
     * Sets the smoothing decay time.
     */
    setDamperDecayTime(decayMilliseconds: number): void;
    moveBy(amount: Vector3): void;
    rotateBy(amount: Vector2): void;
    protected connect(): void;
    protected disconnect(): void;
    dispose(): void;
    protected rotate(euler: Euler): void;
    protected onMouseMove: (event: PointerEvent) => void;
    protected onKeyDown: (event: KeyboardEvent) => void;
    protected onKeyUp: (event: KeyboardEvent) => void;
    protected onContextMenu: () => void;
    protected cancelMove(): void;
}
export { FlyControls };
