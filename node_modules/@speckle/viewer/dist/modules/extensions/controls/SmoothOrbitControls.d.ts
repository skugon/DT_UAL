import { Matrix3, Spherical, Vector2, Vector3, PerspectiveCamera, Sphere, Matrix4, OrthographicCamera, Quaternion, Mesh } from 'three';
import { Damper } from '../../utils/Damper.js';
import { World } from '../../World.js';
import { SpeckleControls } from './SpeckleControls.js';
import SpeckleRenderer from '../../SpeckleRenderer.js';
import { ExtendedMeshIntersection } from '../../objects/SpeckleRaycaster.js';
export type TouchMode = null | ((dx: number, dy: number) => void);
export type TouchAction = 'pan-y' | 'pan-x' | 'none';
export interface Pointer {
    clientX: number;
    clientY: number;
    id: number;
}
export interface SmoothOrbitControlsOptions {
    enableOrbit?: boolean;
    enableZoom?: boolean;
    enablePan?: boolean;
    orbitSensitivity?: number;
    zoomSensitivity?: number;
    panSensitivity?: number;
    inputSensitivity?: number;
    minimumRadius?: number;
    maximumRadius?: number;
    minimumPolarAngle?: number;
    maximumPolarAngle?: number;
    minimumAzimuthalAngle?: number;
    maximumAzimuthalAngle?: number;
    minimumFieldOfView?: number;
    maximumFieldOfView?: number;
    touchAction?: TouchAction;
    infiniteZoom?: boolean;
    zoomToCursor?: boolean;
    orbitAroundCursor?: boolean;
    showOrbitPoint?: boolean;
    damperDecay?: number;
}
export declare enum PointerChangeEvent {
    PointerChangeStart = "pointer-change-start",
    PointerChangeEnd = "pointer-change-end"
}
/**
 * SmoothControls is a Three.js helper for adding delightful pointer and
 * keyboard-based input to a staged Three.js scene. Its API is very similar to
 * OrbitControls, but it offers more opinionated (subjectively more delightful)
 * defaults, easy extensibility and subjectively better out-of-the-box keyboard
 * support.
 *
 * One important change compared to OrbitControls is that the `update` method
 * of SmoothControls must be invoked on every frame, otherwise the controls
 * will not have an effect.
 *
 * Another notable difference compared to OrbitControls is that SmoothControls
 * does not currently support panning (but probably will in a future revision).
 *
 * Like OrbitControls, SmoothControls assumes that the orientation of the camera
 * has been set in terms of position, rotation and scale, so it is important to
 * ensure that the camera's matrixWorld is in sync before using SmoothControls.
 */
export declare class SmoothOrbitControls extends SpeckleControls {
    protected _enabled: boolean;
    protected _options: Required<SmoothOrbitControlsOptions>;
    protected isUserPointing: boolean;
    enablePan: boolean;
    enableTap: boolean;
    protected panProjection: Matrix3;
    protected panPerPixel: number;
    spherical: Spherical;
    protected goalSpherical: Spherical;
    protected origin: Vector3;
    protected pivotalOrigin: Vector3;
    protected goalOrigin: Vector3;
    protected targetDamperX: Damper;
    protected targetDamperY: Damper;
    protected targetDamperZ: Damper;
    protected thetaDamper: Damper;
    protected phiDamper: Damper;
    protected radiusDamper: Damper;
    protected logFov: number;
    protected goalLogFov: number;
    protected fovDamper: Damper;
    protected touchMode: TouchMode;
    protected pointers: Pointer[];
    protected startPointerPosition: {
        clientX: number;
        clientY: number;
    };
    protected lastSeparation: number;
    protected touchDecided: boolean;
    protected zoomControlCoord: Vector2;
    protected _targetCamera: PerspectiveCamera | OrthographicCamera;
    protected _container: HTMLElement;
    protected _lastTick: number;
    protected _basisTransform: Matrix4;
    protected _basisTransformInv: Matrix4;
    protected _radiusDelta: number;
    protected world: World;
    protected renderer: SpeckleRenderer;
    protected orbitSphere: Mesh;
    protected pivotPoint: Vector3;
    protected lastPivotPoint: Vector3;
    protected usePivotal: boolean;
    protected _minDist: number;
    get enabled(): boolean;
    set enabled(value: boolean);
    get up(): Vector3;
    set up(value: Vector3);
    constructor(camera: PerspectiveCamera | OrthographicCamera, container: HTMLElement, world: World, renderer: SpeckleRenderer, options: Required<SmoothOrbitControlsOptions>);
    /**
     * The options that are currently configured for the controls instance.
     */
    get options(): Required<SmoothOrbitControlsOptions>;
    set options(value: SmoothOrbitControlsOptions);
    set targetCamera(value: PerspectiveCamera | OrthographicCamera);
    set minDist(value: number);
    /** The input position and target will be in a basis with (0,1,0) as up */
    fromPositionAndTarget(position: Vector3, target: Vector3): void;
    /**
     * Move the camera instantly instead of accelerating toward the goal
     * parameters.
     */
    jumpToGoal(): void;
    fitToSphere(sphere: Sphere): void;
    /**
     * Gets the current goal position
     */
    getPosition(): Vector3;
    /**
     * Gets the point in model coordinates the model should orbit/pivot around.
     */
    getTarget(): Vector3;
    /**
     * Gets the current goal position
     */
    getCurrentPosition(): Vector3;
    /**
     * Gets the point in model coordinates the model should orbit/pivot around.
     */
    getCurrentTarget(): Vector3;
    isStationary(): boolean;
    /**
     * Configure the _options of the controls. Configured _options will be
     * merged with whatever _options have already been configured for this
     * controls instance.
     */
    protected applyOptions(_options: SmoothOrbitControlsOptions): void;
    /** Computes min/max radius values based on the current world size */
    protected computeMinMaxRadius(): void;
    /**
     * Set the absolute orbital goal of the camera. The change will be
     * applied over a number of frames depending on configured acceleration and
     * dampening _options.
     *
     * Returns true if invoking the method will result in the camera changing
     * position and/or rotation, otherwise false.
     */
    setOrbit(goalTheta?: number, goalPhi?: number, goalRadius?: number): boolean;
    /**
     * Subset of setOrbit() above, which only sets the camera's radius.
     */
    setRadius(radius: number): void;
    /**
     * Sets the goal field of view for the camera
     */
    setFieldOfView(fov: number): void;
    /**
     * Sets the smoothing decay time.
     */
    setDamperDecayTime(decayMilliseconds: number): void;
    /**
     * Sets the point in model coordinates the object should orbit/pivot around.
     */
    setTarget(x: number, y: number, z: number): void;
    /**
     * Adjust the orbital position of the camera relative to its current orbital
     * position. Does not let the theta goal get more than pi ahead of the current
     * theta, which ensures interpolation continues in the direction of the delta.
     * The deltaZoom parameter adjusts both the field of view and the orbit radius
     * such that they progress across their allowed ranges in sync.
     */
    adjustOrbit(deltaTheta: number, deltaPhi: number, deltaZoom: number): void;
    /**
     * Update controls. In most cases, this will result in the camera
     * interpolating its position and rotation until it lines up with the
     * designated goal orbital position. Returns false if the camera did not move.
     *
     * Time and delta are measured in milliseconds.
     */
    update(delta?: number): boolean;
    /** Function expects the position argument to be in a CS where Y is up */
    protected polarFromPivotal(position: Vector3): void;
    /** Function expects the origin argument to be in a CS where Y is up */
    protected positionFromPivotal(origin: Vector3, quaternion: Quaternion): Vector3;
    /** Function expects the pivotPoint and position arguments to be in a CS where Y is up */
    protected getPivotalOrigin(pivotPoint: Vector3, position: Vector3, quaternion: Quaternion): Vector3;
    protected moveCamera(): boolean;
    /** Three.js Spherical assumes (0, 1, 0) as up... */
    protected positionFromSpherical(spherical: Spherical, origin?: Vector3): Vector3;
    /** Three.js Spherical assumes (0, 1, 0) as up... */
    protected quaternionFromSpherical(spherical: Spherical): Quaternion;
    protected userAdjustOrbit(deltaTheta: number, deltaPhi: number, deltaZoom: number): void;
    protected enableInteraction(): void;
    protected disableInteraction(): void;
    protected wrapAngle(radians: number): number;
    protected pixelLengthToSphericalAngle(pixelLength: number): number;
    protected twoTouchDistance(touchOne: Pointer, touchTwo: Pointer): number;
    protected touchModeZoom: TouchMode;
    protected disableScroll: (event: TouchEvent) => void;
    protected touchModeRotate: TouchMode;
    protected handleSinglePointerMove(dx: number, dy: number): void;
    protected initializePan(): void;
    protected movePan(dx: number, dy: number): void;
    /** By default hidden objects are ignored when picking for orbit around cursor */
    protected filterOrbitToCursorHits(hit: ExtendedMeshIntersection): boolean;
    protected onPointerDown: (event: PointerEvent) => void;
    protected onPointerMove: (event: PointerEvent) => void;
    protected onPointerUp: (event: PointerEvent) => void;
    protected onTouchChange(event: PointerEvent): void;
    protected onMouseDown(event: MouseEvent): void;
    protected onWheel: (event: WheelEvent) => void;
    protected onContext: (event: MouseEvent) => void;
    dispose(): void;
}
