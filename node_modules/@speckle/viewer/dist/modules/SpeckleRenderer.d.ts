import { Box3, DirectionalLight, Group, Material, Object3D, Plane, Scene, Sphere, Texture, Vector3, PerspectiveCamera, OrthographicCamera } from 'three';
import { type Batch } from './batching/Batch.js';
import Batcher from './batching/Batcher.js';
import Input from './input/Input.js';
import { Intersections } from './Intersections.js';
import { NodeRenderView } from './tree/NodeRenderView.js';
import { Viewer } from './Viewer.js';
import { WorldTree, type TreeNode } from './tree/WorldTree.js';
import { ObjectLayers, type SunLightConfiguration } from '../IViewer.js';
import { Shadowcatcher } from './Shadowcatcher.js';
import { type ExtendedIntersection } from './objects/SpeckleRaycaster.js';
import { BatchObject } from './batching/BatchObject.js';
import { type SpeckleCamera } from './objects/SpeckleCamera.js';
import { type RenderMaterial, type DisplayStyle, type FilterMaterial } from './materials/Materials.js';
import { type MaterialOptions } from './materials/MaterialOptions.js';
import { SpeckleWebGLRenderer } from './objects/SpeckleWebGLRenderer.js';
import { RenderTree } from './tree/RenderTree.js';
import { Pipeline } from './pipeline/Pipelines/Pipeline.js';
import { OBB } from 'three/examples/jsm/math/OBB.js';
import '../type-augmentations/three-extensions.js';
export declare class RenderingStats {
    private renderTimeAcc;
    private renderTimeSamples;
    private readonly renderTimeMaxSamples;
    private renderTimeStart;
    renderTime: number;
    objects: number;
    batchCount: number;
    drawCalls: number;
    trisCount: number;
    vertCount: number;
    batchDetails: Array<{
        drawCalls: number;
        minDrawCalls: number;
        tris: number;
        verts: number;
    }>;
    frameStart(): void;
    frameEnd(): void;
}
export interface ObjectPickConfiguration {
    pickedObjectsFilter: ((arg: [NodeRenderView, Material]) => boolean) | null;
}
export declare const DefaultObjectPickConfiguration: {
    pickedObjectsFilter: (arg: [NodeRenderView, Material]) => boolean;
};
export default class SpeckleRenderer {
    protected readonly SHOW_HELPERS = false;
    protected readonly IGNORE_ZERO_OPACITY_OBJECTS = true;
    SHOW_BVH: boolean;
    protected _renderer: SpeckleWebGLRenderer;
    protected _renderinStats: RenderingStats;
    protected _scene: Scene;
    protected _needsRender: boolean;
    protected _intersections: Intersections;
    protected _shadowcatcher: Shadowcatcher;
    protected _speckleCamera: SpeckleCamera | null;
    protected container: HTMLElement;
    protected rootGroup: Group;
    protected _pipeline: Pipeline;
    protected sun: DirectionalLight;
    protected sunConfiguration: SunLightConfiguration;
    protected sunTarget: Object3D;
    protected tree: WorldTree;
    protected cancel: {
        [subtreeId: string]: boolean;
    };
    protected _clippingPlanes: Plane[];
    protected _clippingVolume: OBB;
    protected _renderOverride: (() => void) | null;
    objectPickConfiguration: ObjectPickConfiguration;
    viewer: Viewer;
    batcher: Batcher;
    input: Input;
    /********************************
     * Renderer and rendering flags */
    get renderer(): SpeckleWebGLRenderer;
    set needsRender(value: boolean);
    set shadowMapNeedsUpdate(value: boolean);
    /**********************
     * Bounds and volumes */
    get sceneBox(): Box3;
    get visibleSceneBox(): Box3;
    get sceneSphere(): Sphere;
    get sceneCenter(): Vector3;
    get clippingVolume(): OBB;
    set clippingVolume(box: Box3 | OBB);
    /*****************
     * Clipping planes */
    get clippingPlanes(): Plane[];
    set clippingPlanes(value: Plane[]);
    /****************
     * Common Objects */
    get allObjects(): Object3D;
    get scene(): Scene;
    /********
     * Lights */
    get sunLight(): DirectionalLight;
    set indirectIBL(texture: Texture);
    set indirectIBLIntensity(value: number);
    /********
     * Camera */
    get speckleCamera(): SpeckleCamera | null;
    set speckleCamera(value: SpeckleCamera);
    get renderingCamera(): PerspectiveCamera | OrthographicCamera | null;
    /**********
     * Pipeline */
    set pipeline(value: Pipeline);
    get pipeline(): Pipeline;
    get shadowcatcher(): Shadowcatcher | null;
    /**************
     * Intersections */
    get intersections(): Intersections;
    /*****************
     * Rendering Stats */
    get renderingStats(): RenderingStats;
    constructor(tree: WorldTree, viewer: Viewer /** TEMPORARY */);
    create(container: HTMLElement): void;
    update(deltaTime: number): void;
    private updateRTEShadowBuffers;
    private updateRTEShadows;
    private updateTransforms;
    resetPipeline(): void;
    render(): void;
    resize(width?: number, height?: number): void;
    addRenderTree(renderTree: RenderTree): AsyncGenerator<undefined, void, unknown>;
    private addBatch;
    removeRenderTree(subtreeId: string): void;
    cancelRenderTree(subtreeId: string): void;
    setMaterial(rvs: NodeRenderView[], material: Material): void;
    setMaterial(rvs: NodeRenderView[], material: RenderMaterial & DisplayStyle & MaterialOptions): void;
    setMaterial(rvs: NodeRenderView[], material: FilterMaterial): void;
    private setMaterialInstance;
    private setFilterMaterial;
    private setDataMaterial;
    /** TO DO!
     * This can mess up materials if multiple materials exist in the ranges argument */
    private flattenDrawRanges;
    getMaterial(rv: NodeRenderView): Material | null;
    getBatchMaterial(rv: NodeRenderView): Material | null;
    resetMaterials(): void;
    getBatch(id: string): Batch;
    updateClippingPlanes(): void;
    updateShadowCatcher(force?: boolean): void;
    private addDirectLights;
    private updateDirectLights;
    setSunLightConfiguration(config: SunLightConfiguration): void;
    private updateHelpers;
    queryHits(results: Array<ExtendedIntersection>): Array<{
        node: TreeNode;
        point: Vector3;
    }> | null;
    queryHitIds(results: Array<ExtendedIntersection>): Array<{
        nodeId: string;
        point: Vector3;
    }> | null;
    renderViewFromIntersection(intersection: ExtendedIntersection): [NodeRenderView, Material];
    private onClick;
    private onDoubleClick;
    boxFromObjects(objectIds: string[]): Box3;
    screenToNDC(clientX: number, clientY: number, width?: number, height?: number): {
        x: number;
        y: number;
    };
    NDCToScreen(clientX: number, clientY: number, width?: number, height?: number): {
        x: number;
        y: number;
    };
    debugShowBatches(): void;
    getBatchIds(): string[];
    getBatchSize(batchId: string): number;
    isolateBatch(batchId: string): void;
    getObjects(): BatchObject[];
    getObject(rv: NodeRenderView): BatchObject | null;
    enableLayers(layers: ObjectLayers[], value: boolean): void;
}
