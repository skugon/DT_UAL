export declare const speckleDepthNormalIdVert = "\n#include <common>\n#ifdef USE_RTE\n    // The high component is stored as the default 'position' attribute buffer\n    attribute vec3 position_low;\n    uniform vec3 uViewer_high;\n    uniform vec3 uViewer_low;\n    uniform mat4 rteModelViewMatrix;\n#endif\n\n#if defined( TRANSFORM_STORAGE ) || ( defined( USE_INSTANCING ) && __VERSION__ == 100)\n    attribute float objIndex;\n#endif\n\n#ifdef TRANSFORM_STORAGE\n    #if TRANSFORM_STORAGE == 0\n        #if __VERSION__ == 300\n            #define TRANSFORM_STRIDE 4\n        #else\n            #define TRANSFORM_STRIDE 4.\n        #endif\n        uniform sampler2D tTransforms;\n        uniform float objCount;\n    #elif TRANSFORM_STORAGE == 1\n        uniform mat4 uTransforms[OBJ_COUNT];\n    #endif\n#endif\n\nvarying vec3 vIdColor;\nuniform int batchIndex;\n\n#ifdef LINEAR_DEPTH\n    varying vec4 vViewPosition;\n#endif\nvarying vec3 vNormal;\n\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.\n// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for\n// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.\nvarying vec2 vHighPrecisionZW;\n\n#ifdef TRANSFORM_STORAGE\n    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){\n        #if TRANSFORM_STORAGE == 0\n            #if __VERSION__ == 300\n                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); \n                vec4 v0 = texelFetch( tTransforms, uv, 0 );\n                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);\n                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);\n                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);\n                quaternion = v0;\n                pivotLow = vec4(v1.xyz, 1.);\n                pivotHigh = vec4(v2.xyz, 1.);\n                translation = vec4(v3.xyz, 1.);\n                scale = vec4(v1.w, v2.w, v3.w, 1.);\n            #else\n                float size = objCount * TRANSFORM_STRIDE;\n                vec2 cUv = vec2(0.5/size, 0.5);\n                vec2 dUv = vec2(1./size, 0.);\n                \n                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);\n                vec4 v0 = texture2D( tTransforms, uv);\n                vec4 v1 = texture2D( tTransforms, uv + dUv);\n                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);\n                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);\n                quaternion = v0;\n                pivotLow = vec4(v1.xyz, 1.);\n                pivotHigh = vec4(v2.xyz, 1.);\n                translation = vec4(v3.xyz, 1.);\n                scale = vec4(v1.w, v2.w, v3.w, 1.);\n            #endif\n        #elif TRANSFORM_STORAGE == 1\n            mat4 tMatrix = uTransforms[int(objIndex)];\n            quaternion = tMatrix[0];\n            pivotLow = vec4(tMatrix[1].xyz, 1.);\n            pivotHigh = vec4(tMatrix[2].xyz, 1.);\n            translation = vec4(tMatrix[3].xyz, 1.);\n            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);\n        #endif\n    }\n\n    vec3 rotate_vertex_position(vec3 position, vec4 quat)\n    { \n        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);\n    }\n\n    /** Another workaround for Apple's stupid compiler */\n    vec4 safeMul(vec4 a, vec4 b) {\n        // Prevents constant folding and optimization\n        return (a + vec4(0.0)) * (b + vec4(1.0)) - a * vec4(1.0);\n    }\n\n    highp vec3 rotate_scaled_vertex_position_delta(highp vec4 v0, highp vec4 v1, highp vec4 scale, highp vec4 quat)\n    {\n        /** !!! WORKAROUND FOR Intel IrisXe CARDS !!! */\n        /** The code below will not produce correct results in intel IrisXE integrated GPUs. \n         *  The geometry will turn mangled, albeit stable\n         *  I can't know for sure what is going on, but rotating the difference seems to \n         *  force the result into a lower precision?\n         */\n        // highp vec4 position = v0 - v1;\n        // return position.xyz + 2.0 * cross(quat.xyz, cross(quat.xyz, position.xyz) + quat.w * position.xyz);\n\n        /** Subtracting the rotated vectors works. */\n        return rotate_vertex_position(safeMul(v0, scale).xyz, quat)  - rotate_vertex_position(safeMul(v1, scale).xyz, quat) ;\n\n        /** An alternate workaround is\n         * highp vec3 position = (v0.xyz * (1. + 1e-7)) - (v1.xyz * (1. + 1e-7));\n           return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);\n\n           However I'm not such a fan of the (1. + 1e-7) part\n         */\n    }\n#endif\n\n#ifdef USE_RTE\n    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){\n        /* \n        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl \n        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy \n        */\n        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;\n        highp vec3 e = t1 - position_low.xyz;\n        /** This is redunant, but necessary as a workaround for Apple platforms */\n        highp float x = position_high.x - relativeTo_high.x;\n        highp float y = position_high.y - relativeTo_high.y;\n        highp float z = position_high.z - relativeTo_high.z;\n        highp vec3 v = vec3(x, y, z);\n        /** End of redundant part */\n        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;\n        highp vec3 highDifference = t1 + t2;\n        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);\n        \n        highp vec3 position = highDifference.xyz + lowDifference.xyz;\n        return vec4(position, 1.);\n    }\n#endif\n\n\n/** Original glsl100 and glsl300 hash functions. Good outputs but maybe a bit slow? */\n/*\n#if __VERSION__ == 300\n    vec3 hashColor(uint id) {\n        // A simple integer hash function\n        id = (id ^ 61u) ^ (id >> 16u);\n        id = id * 9u;\n        id = id ^ (id >> 4u);\n        id = id * 0x27d4eb2du;\n        id = id ^ (id >> 15u);\n\n        return vec3(\n            float((id >> 16u) & 0xFFu) / 255.0,\n            float((id >> 8u) & 0xFFu) / 255.0,\n            float(id & 0xFFu) / 255.0\n        );\n    }\n#elif __VERSION__ == 100\n    vec3 hashColor(float id) {\n        // Step 1: Simulate XOR by using mod and floating-point arithmetic\n        id = mod(id + 61.0, 4294967296.0);\n        id = mod(id - floor(id / 65536.0), 4294967296.0); // Approximate id ^ (id >> 16)\n        // Step 2: Multiply by 9 (same as original)\n        id = mod(id * 9.0, 4294967296.0);\n        // Step 3: Simulate XOR with division/mod trick\n        id = mod(id - floor(id / 16.0), 4294967296.0); // Approximate id ^ (id >> 4)\n        // Step 4: Multiply by large prime\n        id = mod(id * 666083407.0, 4294967296.0); // Approximate * 0x27d4eb2dU\n        // Step 5: Simulate final XOR\n        id = mod(id - floor(id / 32768.0), 4294967296.0); // Approximate id ^ (id >> 15)\n        // Convert hash to RGB by extracting \"fake\" bit shifts\n        return vec3(\n            mod(floor(id / 65536.0), 256.0) / 255.0, // Simulates (id >> 16) & 0xFF\n            mod(floor(id / 256.0), 256.0) / 255.0,   // Simulates (id >> 8) & 0xFF\n            mod(id, 256.0) / 255.0                   // Simulates id & 0xFF\n        );\n    }\n#endif\n*/\n\n/** Simpler hash function works on both glsl versions */\nhighp vec3 hashColor(float id) {\n    // Large prime multipliers\n    highp float r = mod(id * 127.1, 256.0) / 255.0;\n    highp float g = mod(id * 987.654, 256.0) / 255.0;\n    highp float b = mod(id * 4321.123, 256.0) / 255.0;\n    \n    return vec3(r, g, b);\n}\n\nint szudzikHash(int x, int y) {\n    return (x >= y) ? (x * x + x + y) : (y * y + x);\n}\n\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n    #include <beginnormal_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n    // #include <defaultnormal_vertex> // COMMENTED CHUNK\n    vec3 transformedNormal = objectNormal;\n    #ifdef USE_INSTANCING\n\n        // this is in lieu of a per-instance normal-matrix\n        // shear transforms in the instance matrix are not supported\n        mat3 m = mat3( instanceMatrix );\n        transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n        transformedNormal = m * transformedNormal;\n        \n        /* If we have negative scaling, we flip the normal */\n        float signDet = sign(dot(m[0], cross(m[1], m[2])));\n        // Optional fallback: treat 0 as +1\n        signDet = signDet + (1.0 - abs(signDet));\n        transformedNormal *= signDet;\n    #endif\n    transformedNormal = normalMatrix * transformedNormal;\n    #ifdef FLIP_SIDED\n        transformedNormal = - transformedNormal;\n    #endif\n    #ifdef USE_TANGENT\n        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n        #ifdef FLIP_SIDED\n            transformedTangent = - transformedTangent;\n        #endif\n    #endif\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t//#include <project_vertex> // EDITED CHUNK\n    #ifdef TRANSFORM_STORAGE\n        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;\n        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);\n    #endif\n    #ifdef USE_RTE\n        vec4 position_lowT = vec4(position_low, 1.);\n        vec4 position_highT = vec4(position, 1.);\n        const vec3 ZERO3 = vec3(0., 0., 0.);\n\n        highp vec4 rteLocalPosition = computeRelativePosition(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);\n        #ifdef TRANSFORM_STORAGE\n            highp vec4 rtePivot = computeRelativePosition(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);\n            rteLocalPosition.xyz = rotate_scaled_vertex_position_delta(rteLocalPosition, rtePivot, tScale, tQuaternion) + rtePivot.xyz + tTranslation.xyz;\n        #endif\n        #ifdef USE_INSTANCING\n            vec4 instancePivot = computeRelativePosition(ZERO3, ZERO3, uViewer_low, uViewer_high);\n            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;\n        #endif\n    #endif\n\n    #ifdef USE_RTE\n        vec4 mvPosition = rteLocalPosition;\n    #else\n        vec4 mvPosition = vec4( transformed, 1.0 );\n        #ifdef TRANSFORM_STORAGE\n            mvPosition.xyz = rotate_scaled_vertex_position_delta(mvPosition, tPivotHigh, tScale, tQuaternion) + tPivotHigh.xyz + tTranslation.xyz;\n        #endif\n        #ifdef USE_INSTANCING\n            mvPosition = instanceMatrix * mvPosition;\n        #endif\n    #endif\n   \n    #ifdef USE_RTE\n        mvPosition = rteModelViewMatrix * mvPosition;\n    #else\n        mvPosition = modelViewMatrix * mvPosition;\n    #endif\n    \n    #ifdef LINEAR_DEPTH\n        vViewPosition = mvPosition;\n    #endif \n\n    vNormal = normalize( transformedNormal );\n    \n    #ifdef TRANSFORM_STORAGE\n        vIdColor = hashColor(float(szudzikHash(int(objIndex), batchIndex)));\n    #else\n        #if defined( USE_INSTANCING ) \n            #if __VERSION__ == 300\n                vIdColor = hashColor(float(szudzikHash(int(gl_InstanceID), batchIndex)));\n            #elif __VERSION__ == 100\n                vIdColor = hashColor(float(szudzikHash(int(objIndex), batchIndex)));\n            #endif\n        #else\n            vIdColor = vec3(0.);\n        #endif\n    #endif\n\n\n    gl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t// #include <clipping_planes_vertex>\n    #if NUM_CLIPPING_PLANES > 0\n\t    vClipPosition = - mvPosition.xyz;\n    #endif\n\tvHighPrecisionZW = gl_Position.zw;\n}\n";
