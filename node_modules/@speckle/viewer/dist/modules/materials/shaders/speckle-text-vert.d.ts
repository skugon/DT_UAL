export declare const speckleTextVert = "\n#include <common>\n#ifdef USE_RTE\n    uniform vec3 uViewer_high;\n    uniform vec3 uViewer_low;\n#endif\n\n#if defined(BILLBOARD) || defined(BILLBOARD_SCREEN)\n    uniform mat4 invProjection;\n#endif\n\n#ifdef BILLBOARD_SCREEN\n    uniform vec4 billboardPixelOffsetSize;\n#endif\n\n\n\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef USE_RTE\n    highp vec4 computeRelativePosition(in highp vec3 position_low, in highp vec3 position_high, in highp vec3 relativeTo_low, in highp vec3 relativeTo_high){\n        /* \n        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl \n        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy \n        */\n        highp vec3 t1 = position_low.xyz - relativeTo_low.xyz;\n        highp vec3 e = t1 - position_low.xyz;\n        /** This is redunant, but necessary as a workaround for Apple platforms */\n        highp float x = position_high.x - relativeTo_high.x;\n        highp float y = position_high.y - relativeTo_high.y;\n        highp float z = position_high.z - relativeTo_high.z;\n        highp vec3 v = vec3(x, y, z);\n        /** End of redundant part */\n        highp vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + v;\n        highp vec3 highDifference = t1 + t2;\n        highp vec3 lowDifference = t2 - (highDifference.xyz - t1.xyz);\n        \n        highp vec3 position = highDifference.xyz + lowDifference.xyz;\n        return vec4(position, 1.);\n    }\n#endif\n\n\n#ifdef BATCHED_TEXT\n    varying float vGradientIndex;\n#endif\n\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n        // #include <defaultnormal_vertex> // COMMENTED CHUNK\n        vec3 transformedNormal = objectNormal;\n        #ifdef USE_INSTANCING\n\n            // this is in lieu of a per-instance normal-matrix\n            // shear transforms in the instance matrix are not supported\n            mat3 m = mat3( instanceMatrix );\n            transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n            transformedNormal = m * transformedNormal;\n            \n            /* If we have negative scaling, we flip the normal */\n            float signDet = sign(dot(m[0], cross(m[1], m[2])));\n            // Optional fallback: treat 0 as +1\n            signDet = signDet + (1.0 - abs(signDet));\n            transformedNormal *= signDet;\n        #endif\n        transformedNormal = normalMatrix * transformedNormal;\n        #ifdef FLIP_SIDED\n            transformedNormal = - transformedNormal;\n        #endif\n        #ifdef USE_TANGENT\n            vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n            #ifdef FLIP_SIDED\n                transformedTangent = - transformedTangent;\n            #endif\n        #endif\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\n    vec4 mvPosition;\n    mat4 matrix;\n\n    #ifdef BATCHED_TEXT\n        matrix = mat4(\n            troikaBatchTexel(0.0), \n            troikaBatchTexel(1.0), \n            troikaBatchTexel(2.0), \n            troikaBatchTexel(3.0)\n        );\n    #else\n        matrix = modelMatrix;\n    #endif\n\n    #ifdef USE_RTE\n        /* We store the high part normally as the translation component */\n        vec3 translationHigh = matrix[3].xyz;\n        /** We store the low part of the translation in row4 ofthe matrix */\n        vec3 translationLow = vec3(matrix[0][3], matrix[1][3], matrix[2][3]);\n        highp vec4 rteTranslation = computeRelativePosition(translationLow, translationHigh, uViewer_low, uViewer_high);\n        #if defined(BILLBOARD)\n            mvPosition = (modelViewMatrix * rteTranslation + vec4(position.x, position.y, 0., 0.0));\n        #else\n             mvPosition = vec4(mat3(matrix) * transformed + rteTranslation.xyz, 1.);\n             mvPosition = modelViewMatrix * mvPosition;\n        #endif\n    #else\n        #if defined(BILLBOARD) || defined(BILLBOARD_SCREEN)\n            vec3 billboardPosition = matrix[3].xyz;\n            #if defined(BILLBOARD_SCREEN)\n                mvPosition = projectionMatrix * (viewMatrix * vec4(billboardPosition, 1.0));\n                float div = mvPosition.w;\n                mvPosition /= mvPosition.w;\n                // Pixel values are computed like so\n                // windowX = ((ndc.x + 1) / 2) * width;\n                // windowY = ((ndc.y + 1) / 2) * height;\n                // That's why we multiply by 2.\n                mvPosition.xy += position.xy * billboardPixelOffsetSize.zw * 2. + billboardPixelOffsetSize.xy * 2.;\n                /** Back to view space for convenience */\n                mvPosition *= div;\n                mvPosition = invProjection * mvPosition;\n            #else\n                mvPosition = (viewMatrix * vec4(billboardPosition, 1.) + vec4(position.x, position.y, 0., 0.0));\n            #endif\n        #else\n             mvPosition = viewMatrix * matrix * vec4(transformed, 1.);\n        #endif\n    #endif\n\n    #ifdef BATCHED_TEXT\n        vGradientIndex = troikaBatchTexel(6.).w;\n    #endif\n\n    gl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex> \n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";
