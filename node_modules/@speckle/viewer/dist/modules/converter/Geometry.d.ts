import { Box3, BufferGeometry, Matrix4, Vector2, Vector3 } from 'three';
import { type SpeckleObject } from '../../IViewer.js';
import { ChunkArray } from './VirtualArray.js';
export declare enum GeometryAttributes {
    POSITION = "POSITION",
    COLOR = "COLOR",
    NORMAL = "NORMAL",
    UV = "UV",
    TANGENT = "TANGENT",
    INDEX = "INDEX"
}
type RequiredKeys = GeometryAttributes.POSITION | GeometryAttributes.INDEX;
type OptionalKeys = Exclude<GeometryAttributes, RequiredKeys>;
type GeometryAttributesShape = {
    [K in RequiredKeys]: ChunkArray;
} & {
    [K in OptionalKeys]?: ChunkArray;
};
export interface GeometryData {
    attributes: GeometryAttributesShape | null;
    bakeTransform: Matrix4 | null;
    transform: Matrix4 | null;
    metaData?: SpeckleObject;
    instanced?: boolean;
    flipNormals?: boolean;
}
export declare class Geometry {
    static updateRTEGeometry(geometry: BufferGeometry, doublePositions: Float64Array | Float32Array): void;
    static mergeGeometryAttribute(attributes: ChunkArray[], target: Float32Array | Float64Array): ArrayLike<number>;
    static mergeIndexAttribute(indexAttributes: ChunkArray[], positionAttributes: ChunkArray[]): number[];
    static mergeGeometryData(geometries: GeometryData[]): GeometryData;
    static transformGeometryData(geometryData: GeometryData, m: Matrix4 | null): void;
    static transformArray(array: number[] | Float32Array | Float64Array, m: Matrix4 | null, offset?: number, count?: number): void;
    static isMatrix4Identity(matrix: Matrix4): boolean;
    static unpackColors(int32Colors: number[]): number[];
    /** Please see https://speckle.systems/blog/improving-speckles-rte-implementation/ for additional details
     *  regarding double -> <float low; float high> encoding.
     */
    static DoubleToHighLowVector(input: Vector3, low: Vector3, high: Vector3): void;
    static DoubleToHighLowBuffer(input: ArrayLike<number>, position_low: number[] | Float32Array, position_high: number[] | Float32Array): void;
    static needsRTE(bounds: Box3): boolean;
    static getFP32ProjectionDelta(point: Vector3, projection: Matrix4, screenSize: Vector2, relativeOffset?: number): Vector2;
    /** Only supports indexed geometry */
    static computeVertexNormalsBuffer(buffer: number[], position: number[], index: number[]): void;
    static computeVertexNormalsBufferVirtual(buffer: number[], position: ChunkArray, index: ChunkArray, flip?: boolean): void;
    static flipNormalsBuffer(buffer: Float32Array): void;
    static computeVertexNormals(buffer: BufferGeometry, positions: Float64Array | Float32Array): void;
    static triangulatePolygon(points: Vector2[]): number[];
}
export {};
