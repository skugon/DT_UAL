import { Box3, BufferGeometry, Material, Matrix4, Ray, Side, Vector3 } from 'three';
import { ExtendedTriangle, MeshBVH, ShapecastIntersection, SplitStrategy } from 'three-mesh-bvh';
import { MeshIntersection } from './SpeckleRaycaster.js';
declare const SKIP_GENERATION: unique symbol;
export interface BVHOptions {
    strategy: SplitStrategy;
    maxDepth: number;
    maxLeafTris: number;
    verbose: boolean;
    useSharedArrayBuffer: boolean;
    setBoundingBox: boolean;
    onProgress?: () => void;
    [SKIP_GENERATION]: boolean;
}
export declare const DefaultBVHOptions: {
    strategy: SplitStrategy;
    maxDepth: number;
    maxLeafTris: number;
    verbose: boolean;
    useSharedArrayBuffer: boolean;
    setBoundingBox: boolean;
    [SKIP_GENERATION]: boolean;
};
/**
 *
  _____                            _              _
 |_   _|                          | |            | |
   | |  _ __ ___  _ __   ___  _ __| |_ __ _ _ __ | |_
   | | | '_ ` _ \| '_ \ / _ \| '__| __/ _` | '_ \| __|
  _| |_| | | | | | |_) | (_) | |  | || (_| | | | | |_
 |_____|_| |_| |_| .__/ \___/|_|   \__\__,_|_| |_|\__|
                 | |
                 |_|

We've made this wrapper around the original implementation to hide the transformations we do behind the scenes
in order to avoid storing vertex positions as Float64. Instead we store them as Float32, but the whole BVH is
re-centered around the mesh local origin as (0,0,0). We use the resulting transformations to transform anything that comes
in or out of the BVH in order to keep this re-centering opaque.

We've implemented auto-transformation for raycasting and shapecasting. Other functionalities like bvhcast or geometrycast
will need to be wrapped around if required.

Otherwise, keep in mind that if you use this class for any other purposes, you can use transformInput and transformOutput
to get the correct values for Vectors, Rays, Boxes, etc
 */
export declare class AccelerationStructure {
    private static readonly MatBuff;
    private _bvh;
    inputTransform: Matrix4;
    outputTransform: Matrix4;
    inputOriginTransform: Matrix4;
    outputOriginTransfom: Matrix4;
    get geometry(): BufferGeometry;
    get bvh(): MeshBVH;
    static buildBVH(indices: Uint16Array | Uint32Array | undefined, position: Float32Array | Float64Array | undefined, options?: BVHOptions, transform?: Matrix4): MeshBVH;
    constructor(bvh: MeshBVH);
    raycast(ray: Ray, materialOrSide?: Side | Material | Material[]): MeshIntersection[];
    raycastFirst(ray: Ray, materialOrSide?: Side | Material | Material[]): MeshIntersection;
    shapecast(callbacks: {
        intersectsBounds: (box: Box3, isLeaf: boolean, score: number | undefined, depth: number, nodeIndex: number) => ShapecastIntersection | boolean;
        traverseBoundsOrder?: (box: Box3) => number;
    } & ({
        intersectsRange: (triangleOffset: number, triangleCount: number, contained: boolean, depth: number, nodeIndex: number, box: Box3) => boolean;
    } | {
        intersectsTriangle: (triangle: ExtendedTriangle, triangleIndex: number, contained: boolean, depth: number) => boolean | void;
    })): boolean;
    transformInput<T extends Vector3 | Ray | Box3>(input: T): T;
    transformOutput<T extends Vector3 | Ray | Box3>(output: T): T;
    getBoundingBox(target?: Box3): Box3;
    getVertexAtIndex(index: number): Vector3;
}
export {};
