import { BufferGeometry, DataTexture, Material, Matrix4, Mesh, type Intersection } from 'three';
import { BatchObject } from '../batching/BatchObject.js';
import { TopLevelAccelerationStructure } from './TopLevelAccelerationStructure.js';
import { SpeckleRaycaster } from './SpeckleRaycaster.js';
export declare enum TransformStorage {
    VERTEX_TEXTURE = 0,
    UNIFORM_ARRAY = 1
}
export default class SpeckleMesh extends Mesh {
    static MeshBatchNumber: number;
    private tas;
    private batchMaterial;
    private materialCache;
    private materialStack;
    private batchMaterialStack;
    private materialCacheLUT;
    private _batchObjects;
    private _batchIndex;
    private _needsRTE;
    private transformsBuffer;
    private transformStorage;
    transformsTextureUniform: DataTexture;
    transformsArrayUniforms: Matrix4[] | null;
    get TAS(): TopLevelAccelerationStructure;
    get batchObjects(): BatchObject[];
    get batchIndex(): number;
    get needsRTE(): boolean;
    constructor(geometry: BufferGeometry, RTE?: boolean);
    setBatchMaterial(material: Material): void;
    setBatchObjects(batchObjects: BatchObject[], transformStorage: TransformStorage): void;
    setOverrideMaterial(material: Material): void;
    setOverrideBatchMaterial(material: Material): void;
    restoreBatchMaterial(): void;
    private lookupMaterial;
    getCachedMaterial(material: Material, copy?: boolean): Material;
    restoreMaterial(): void;
    updateMaterialTransformsUniform(material: Material): void;
    updateTransformsUniform(): void;
    buildTAS(): void;
    getBatchObjectMaterial(batchObject: BatchObject): Material | null;
    private convertRaycastIntersect;
    raycast(raycaster: SpeckleRaycaster, intersects: Array<Intersection>): void;
}
