import { type TreeNode, WorldTree } from '../../tree/WorldTree.js';
import { type SpeckleObject } from '../../../index.js';
import { ObjectLoader2 } from '@speckle/objectloader2';
export type ConverterResultDelegate = (count: number) => void;
export type SpeckleConverterNodeDelegate = ((object: SpeckleObject, node: TreeNode) => Promise<void>) | null;
/**
 * Utility class providing some top level conversion methods.
 * Warning: HIC SVNT DRACONES.
 */
export default class SpeckleConverter {
    protected objectLoader: ObjectLoader2;
    protected activePromises: number;
    protected maxChildrenPromises: number;
    protected spoofIDs: boolean;
    protected tree: WorldTree;
    protected subtree: TreeNode;
    protected typeLookupTable: {
        [type: string]: string;
    };
    protected instanceDefinitionLookupTable: {
        [id: string]: TreeNode;
    };
    protected instancedObjectsLookupTable: {
        [id: string]: SpeckleObject;
    };
    protected instanceProxies: {
        [id: string]: TreeNode;
    };
    protected renderMaterialMap: {
        [id: string]: SpeckleObject;
    };
    protected colorMap: {
        [id: string]: SpeckleObject;
    };
    protected instanceCounter: number;
    protected duplicateCounter: number;
    private traverseCount;
    protected readonly NodeConverterMapping: {
        [name: string]: SpeckleConverterNodeDelegate;
    };
    protected readonly IgnoreNodes: string[];
    constructor(objectLoader: ObjectLoader2, tree: WorldTree);
    /**
     * If the object is convertible (there is a direct conversion routine), it will invoke the callback with the conversion result.
     * If the object is not convertible, it will recursively iterate through it (arrays & objects) and invoke the callback on any positive conversion result.
     * @param  {[type]}   obj      [description]
     * @param  {Function} callback [description]
     * @return {[type]}            [description]
     */
    traverse(objectURL: string, obj: SpeckleObject, callback: ConverterResultDelegate, node?: TreeNode | null): Promise<void>;
    private getNodeId;
    private addNode;
    /**
     * Takes an array composed of chunked references and dechunks it.
     * @param  {[type]} arr [description]
     * @return {[type]}     [description]
     */
    private dechunk;
    /**
     * Resolves an object reference by waiting for the loader to load it up.
     * @param  {[type]} obj [description]
     * @return {[type]}     [description]
     */
    private resolveReference;
    /**
     * Gets the speckle type of an object in various scenarios.
     * @param  {[type]} obj [description]
     * @return {[type]}     [description]
     */
    private getSpeckleType;
    private getSpeckleTypeChain;
    private directNodeConverterExists;
    private convertToNode;
    private getDisplayValue;
    private getElementsValue;
    private getBlockDefinition;
    private getBlockDefinitionGeometry;
    /** We're wasting a few milis here, but it is what it is */
    private getCompoundId;
    private getDuplicateId;
    private getEmptyTransformData;
    /**
     *
      NODES
     */
    private View3DToNode;
    /** This is only used for Blocks to search for convertible objects, without using the main 'traverse' function
     *  It's only looking for 'elements' and 'displayValues'
     *  I think it can be used for RevitInstances as well to replace it's current lookup, but I'm afraid to do it
     */
    private displayableLookup;
    private parseInstanceDefinitionGeometry;
    private parseInstanceElement;
    private BlockInstanceToNode;
    private RevitInstanceToNode;
    private InstanceDefinitionProxyToNode;
    private InstanceProxyToNode;
    private RenderMaterialProxyToNode;
    private ColorProxyToNode;
    private getInstanceProxyDefinitionId;
    private getInstanceProxyTransform;
    private getInstanceProxyDefinitionObjects;
    private createTransformNode;
    private ConvertInstanceProxyToNode;
    convertInstances(): Promise<void>;
    applyMaterials(): Promise<void>;
    private PointcloudToNode;
    private BrepToNode;
    private MeshToNode;
    private RegionToNode;
    private TextToNode;
    private DimensionToNode;
    private PointToNode;
    private LineToNode;
    private PolylineToNode;
    private BoxToNode;
    private PolycurveToNode;
    private CurveToNode;
    private CircleToNode;
    private ArcToNode;
    private EllipseToNode;
    /** We shouldn't need to work with duplicates */
    handleDuplicates(): Promise<void>;
}
