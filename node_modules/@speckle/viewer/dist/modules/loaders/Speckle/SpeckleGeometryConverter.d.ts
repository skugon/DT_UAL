import { type GeometryData } from '../../converter/Geometry.js';
import { type NodeData } from '../../tree/WorldTree.js';
import { Vector2, Vector3 } from 'three';
import { GeometryConverter, SpeckleType } from '../GeometryConverter.js';
import { DataChunk } from '../../../IViewer.js';
import { ChunkArray } from '../../converter/VirtualArray.js';
export declare class SpeckleGeometryConverter extends GeometryConverter {
    typeLookupTable: {
        [type: string]: SpeckleType;
    };
    meshTriangulationTime: number;
    actualTriangulateTime: number;
    pushTime: number;
    getSpeckleType(node: NodeData): SpeckleType;
    convertNodeToGeometryData(node: NodeData): GeometryData | null;
    disposeNodeGeometryData(node: NodeData): void;
    protected View3DToGeometryData(node: NodeData): GeometryData;
    protected TransformToGeometryData(node: NodeData): GeometryData;
    /** BLOCK INSTANCE */
    protected BlockInstanceToGeometryData(node: NodeData): GeometryData | null;
    /** REVIT INSTANCE */
    protected RevitInstanceToGeometryData(node: NodeData): GeometryData | null;
    /** DUI3 INSTANCE PROXY */
    protected InstanceProxyToGeometyData(node: NodeData): GeometryData | null;
    /**
     * POINT CLOUD
     */
    protected PointcloudToGeometryData(node: NodeData): GeometryData | null;
    /**
     * BREP
     */
    protected BrepToGeometryData(node: NodeData): GeometryData | null;
    /**
     * REGION
     */
    protected RegionGeometyData(node: NodeData): GeometryData | null;
    /**
     * MESH
     */
    protected MeshToGeometryData(node: NodeData): GeometryData | null;
    /**
     * TEXT
     */
    protected TextToGeometryData(node: NodeData): GeometryData | null;
    /**
     * POINT
     */
    protected PointToGeometryData(node: NodeData): GeometryData | null;
    /**
     * LINE
     */
    protected LineToGeometryData(node: NodeData): GeometryData | null;
    /**
     * POLYLINE
     */
    protected PolylineToGeometryData(node: NodeData): GeometryData | null;
    /**
     * BOX
     */
    protected BoxToGeometryData(node: NodeData): GeometryData | null;
    /**
     * POLYCURVE
     */
    protected PolycurveToGeometryData(node: NodeData): GeometryData | null;
    /**
     * CURVE
     */
    protected CurveToGeometryData(node: NodeData): GeometryData | null;
    /**
     * CIRCLE
     */
    protected CircleToGeometryData(node: NodeData): GeometryData | null;
    /**
     * ARC
     */
    protected ArcToGeometryData(node: NodeData): GeometryData | null;
    /**
     * ELLIPSE
     */
    protected EllipseToGeometryData(node: NodeData): GeometryData | null;
    /**
     * UTILS
     */
    protected getCircularCurvePoints(plane: {
        xdir: {
            value: Array<number>;
            units: string;
        } & {
            x: number;
            y: number;
            z: number;
        };
        ydir: {
            value: Array<number>;
            units: string;
        } & {
            x: number;
            y: number;
            z: number;
        };
        origin: {
            value: Array<number>;
            units: string;
        } & {
            x: number;
            y: number;
            z: number;
        };
    }, radius: number, startAngle?: number, endAngle?: number, resolution?: number): Float64Array<ArrayBuffer>;
    protected PointToVector3(obj: {
        value: Array<number>;
        units: string;
    } & {
        x: number;
        y: number;
        z: number;
    }, target?: Vector3, scale?: boolean): Vector3;
    protected PointToFloatArray(obj: {
        value: Array<number>;
        units: string;
    } & {
        x: number;
        y: number;
        z: number;
    }): number[];
    protected FlattenVector3Array(input: Vector3[] | Vector2[]): number[];
    protected unpackColors(int32Colors: ChunkArray, tolinear?: boolean): number[];
    protected srgbToLinear(x: number): number;
    /** Connectors send empty chunks ಠ_ಠ */
    protected chunkArrayHasData(chunks: Array<DataChunk>): boolean;
}
