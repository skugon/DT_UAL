import { err, ok } from 'true-myth/result';
import { SavedViewInvalidUpdateError, SavedViewNotFoundError } from '../../../domain/authErrors.js';
import { ensureCanAccessSavedViewFragment, WriteTypes } from '../../../fragments/savedViews.js';
import { SavedViewVisibility } from '../../../domain/savedViews/types.js';
import { isModelResource, resourceBuilder } from '../../../../viewer/helpers/route.js';
export const canSetSavedViewAsHomeViewPolicy = (loaders) => async ({ userId, projectId, savedViewId }) => {
    const canDoUpdate = await ensureCanAccessSavedViewFragment(loaders)({
        userId,
        projectId,
        savedViewId,
        access: WriteTypes.SetHomeView
    });
    if (canDoUpdate.isErr) {
        return err(canDoUpdate.error);
    }
    const view = await loaders.getSavedView({
        projectId,
        savedViewId
    });
    if (!view)
        return err(new SavedViewNotFoundError());
    // Must be a shared view to be set as home view
    const isAuthorOnly = view.visibility === SavedViewVisibility.authorOnly;
    if (isAuthorOnly) {
        return err(new SavedViewInvalidUpdateError({
            message: 'A view must be shared to be set as a home view'
        }));
    }
    // Must not be federated
    const resourceIds = resourceBuilder().addResources(view.resourceIds);
    const firstResource = resourceIds.toResources().at(0);
    const modelResource = firstResource && isModelResource(firstResource) ? firstResource : undefined;
    const isSingleModelView = resourceIds.length === 1 && modelResource;
    if (!isSingleModelView) {
        return err(new SavedViewInvalidUpdateError({
            message: 'Only single model views can be set as home views'
        }));
    }
    return ok();
};
//# sourceMappingURL=canSetAsHomeView.js.map