import type { MaybeNullOrUndefined, Nullable } from '../../core/helpers/utilityTypes.js';
import type { PartialDeep } from 'type-fest';
export declare const defaultViewModeEdgeColorValue = "DEFAULT_EDGE_COLOR";
/** Redefining these is unfortunate. Especially since they are not part of viewer-core */
export declare enum MeasurementType {
    PERPENDICULAR = 0,
    POINTTOPOINT = 1,
    AREA = 2,
    POINT = 3
}
export interface MeasurementOptions {
    visible: boolean;
    type?: MeasurementType;
    vertexSnap?: boolean;
    units?: string;
    precision?: number;
    chain?: boolean;
}
export interface MeasurementData {
    type: MeasurementType;
    startPoint: readonly [number, number, number];
    endPoint: readonly [number, number, number];
    startNormal: readonly [number, number, number];
    endNormal: readonly [number, number, number];
    value: number;
    innerPoints?: (readonly [number, number, number])[];
    units?: string;
    precision?: number;
    uuid: string;
}
export declare const defaultMeasurementOptions: Readonly<MeasurementOptions>;
export interface SectionBoxData {
    min: number[];
    max: number[];
    rotation?: number[];
}
/**
 * v1 -> v1.1
 * - ui.filters.propertyFilter.isApplied field added
 * - ui.spotlightUserId swapped for spotlightUserSessionId
 * v1.1 -> v1.2
 * - ui.diff added
 * v1.2 -> v1.3
 * - ui.filters.selectedObjectIds removed in favor of ui.filters.selectedObjectApplicationIds
 * v1.3 -> 1.4
 * - ui.viewMode -> ui.viewMode.mode
 * - ui.viewMode has new keys: edgesEnabled, edgesWeight, outlineOpacity, edgesColor
 * v1.4 -> 1.5
 * - ui.measurement.measurements added
 * v1.5 -> 1.6
 * - ui.filters.propertyFilter -> propertyFilters
 * - activeColorFilterId added
 * v1.6 -> 1.7
 * - ui.filters.filterLogic added
 * - ui.filters.propertyFilters.condition updated
 * v1.7 -> 1.8
 * - ui.filters.propertyFilters.numericRange added
 */
export declare const SERIALIZED_VIEWER_STATE_VERSION = 1.8;
export type SerializedViewerState = {
    projectId: string;
    sessionId: string;
    viewer: {
        metadata: {
            filteringState: Nullable<{
                passMin?: MaybeNullOrUndefined<number>;
                passMax?: MaybeNullOrUndefined<number>;
            }>;
        };
    };
    resources: {
        request: {
            resourceIdString: string;
            threadFilters: {
                includeArchived?: MaybeNullOrUndefined<boolean>;
                loadedVersionsOnly?: MaybeNullOrUndefined<boolean>;
            };
        };
    };
    ui: {
        threads: {
            openThread: {
                threadId: Nullable<string>;
                isTyping: boolean;
                newThreadEditor: boolean;
            };
        };
        diff: {
            command: Nullable<string>;
            time: number;
            mode: number;
        };
        spotlightUserSessionId: Nullable<string>;
        filters: {
            isolatedObjectIds: string[];
            hiddenObjectIds: string[];
            /** Map of object id => application id or null, if no application id */
            selectedObjectApplicationIds: Record<string, string | null>;
            propertyFilters: Array<{
                key: Nullable<string>;
                isApplied: boolean;
                selectedValues: string[];
                id: string;
                condition: string;
                numericRange?: {
                    min: number;
                    max: number;
                };
            }>;
            activeColorFilterId: Nullable<string>;
            filterLogic: string;
        };
        camera: {
            position: number[];
            target: number[];
            isOrthoProjection: boolean;
            zoom: number;
        };
        viewMode: {
            mode: number;
            edgesEnabled: boolean;
            edgesWeight: number;
            outlineOpacity: number;
            edgesColor: typeof defaultViewModeEdgeColorValue | number;
        };
        sectionBox: Nullable<SectionBoxData>;
        lightConfig: {
            intensity?: number;
            indirectLightIntensity?: number;
            elevation?: number;
            azimuth?: number;
        };
        explodeFactor: number;
        selection: Nullable<number[]>;
        measurement: {
            enabled: boolean;
            options: Nullable<MeasurementOptions>;
            measurements: Array<MeasurementData>;
        };
    };
};
export type VersionedSerializedViewerState = {
    version: number;
    state: SerializedViewerState;
};
type UnformattedState = PartialDeep<SerializedViewerState & {
    ui: {
        filters: {
            selectedObjectIds: string[];
            propertyFilter: {
                key: Nullable<string>;
                isApplied: boolean;
            };
        };
    };
}>;
/**
 * Note: This only does superficial validation. To really ensure that all of the keys are there, even if prefilled with default values, make sure you invoke
 * formatSerializedViewerState() on the state afterwards
 */
export declare const isSerializedViewerState: (val: unknown) => val is SerializedViewerState;
/**
 * Formats SerializedViewerState by bringing it up to date with the structure of the latest version
 * and ensuring missing keys are initialized with default values
 */
export declare const formatSerializedViewerState: (state: UnformattedState) => SerializedViewerState;
export declare const inputToVersionedState: (inputSerializedViewerState: unknown) => Nullable<VersionedSerializedViewerState>;
export declare const isVersionedSerializedViewerState: (data: unknown) => data is VersionedSerializedViewerState;
export {};
//# sourceMappingURL=state.d.ts.map