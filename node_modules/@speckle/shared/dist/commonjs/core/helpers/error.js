"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErrorMessage = exports.errorToString = exports.collectLongTrace = exports.CleanStackTrace = exports.UncoveredError = void 0;
exports.ensureError = ensureError;
exports.throwUncoveredError = throwUncoveredError;
exports.createUncoveredError = createUncoveredError;
const _lodash_1 = require("#lodash");
class UnexpectedErrorStructureError extends Error {
}
/**
 * In JS catch clauses can receive not only Errors, but pretty much any other kind of data type, so
 * you can use this helper to ensure that whatever is passed in is a real error
 */
function ensureError(e, fallbackMessage) {
    if (e instanceof Error)
        return e;
    let stringifiedError = '';
    if (e !== null && e !== undefined) {
        try {
            stringifiedError = JSON.stringify(e);
        }
        catch {
            //ignore
        }
    }
    return new UnexpectedErrorStructureError(`${fallbackMessage}${stringifiedError !== '' ? `. Cause: ${stringifiedError}` : ''}`);
}
// this makes sure that a case is breaking in typing and in runtime too
function throwUncoveredError(e) {
    throw createUncoveredError(e);
}
class UncoveredError extends Error {
}
exports.UncoveredError = UncoveredError;
function createUncoveredError(e) {
    let errorRepr = e;
    if (typeof e === 'object')
        errorRepr = JSON.stringify(e);
    return new UncoveredError(`Uncovered error case ${errorRepr}.`);
}
/**
 * A custom error class that produces a cleaner stack trace when instantiated.
 */
class CleanStackTrace extends Error {
    constructor() {
        super('');
        this.name = 'Stack trace:';
    }
}
exports.CleanStackTrace = CleanStackTrace;
/**
 * Note: Only V8 and Node.js support controlling the stack trace limit
 */
const collectLongTrace = (limit) => {
    const originalLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = limit || 30;
    const trace = (new CleanStackTrace().stack || '')
        .split('\n')
        .slice(2) // remove "Error" and this function's own frame
        .join('\n')
        .trim();
    Error.stackTraceLimit = originalLimit;
    return trace;
};
exports.collectLongTrace = collectLongTrace;
/**
 * When you need to log a full error representation, w/ full .cause() support
 */
const errorToString = (e) => {
    if (!(e instanceof Error)) {
        try {
            return JSON.stringify(e);
        }
        catch {
            return String(e);
        }
    }
    let ret = e.stack || e.message || String(e);
    const causeProps = ['jse_cause', 'cause'];
    for (const prop of causeProps) {
        if (prop in e) {
            const cause = (0, _lodash_1.get)(e, prop);
            if (!cause)
                continue;
            ret += `\nCause: ${(0, exports.errorToString)(cause)}`;
            break; // avoid chaining multiple causes
        }
    }
    return ret;
};
exports.errorToString = errorToString;
const getErrorMessage = (e) => {
    if (e instanceof Error)
        return e.message;
    if ((0, _lodash_1.isObject)(e) && 'message' in e && (0, _lodash_1.isString)(e.message))
        return e.message;
    if ((0, _lodash_1.isString)(e))
        return e;
    if ((0, _lodash_1.isUndefined)(e))
        return 'undefined';
    try {
        return JSON.stringify(e);
    }
    catch {
        return String(e);
    }
};
exports.getErrorMessage = getErrorMessage;
//# sourceMappingURL=error.js.map