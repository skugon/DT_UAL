import type { MaybeAsync, NonNullableProperties, NullableKeysToOptional } from './utilityTypes.js';
export declare class TimeoutError extends Error {
}
export declare class WaitIntervalUntilCanceledError extends Error {
}
/**
 * Build promise that can be resolved/rejected manually outside of the promise's execution scope
 */
export declare const buildManualPromise: <T>() => {
    promise: Promise<T>;
    resolve: (value: T) => void;
    reject: (reason?: any) => void;
};
export type ManualPromise<T> = ReturnType<typeof buildManualPromise<T>>;
export declare const isNullOrUndefined: (val: unknown) => val is null | undefined;
export declare const wait: (ms: number) => Promise<unknown>;
export declare const waitIntervalUntil: (ms: number, predicate: () => boolean) => Promise<void> & {
    cancel: () => void;
};
/**
 * Not nullable type guard, useful in `.filter()` calls for proper TS typed
 * results
 */
export declare const isNonNullable: <V>(v: V) => v is NonNullable<typeof v>;
/**
 * Make the promise throw after enough time has passed. Useful for implementing timeout functionality in various flows.
 */
export declare const timeoutAt: (ms: number, optionalMessage?: string) => Promise<never>;
/**
 * Invoke and return fn(), but retry it up to n times if it throws
 */
export declare const retry: <V = unknown>(fn: () => MaybeAsync<V>, n: number, delayMs?: number | ((attempt: number, error: Error) => number)) => Promise<V>;
/**
 * For quickly profiling a function
 */
export declare const profile: <V = unknown>(fn: () => MaybeAsync<V>, label?: string, extra?: unknown) => Promise<V>;
/**
 * For quickly profiling a sync function
 */
export declare const profileSync: <V = unknown>(fn: () => V, label?: string, extra?: unknown) => V;
export declare const removeNullOrUndefinedKeys: <T extends Record<string, unknown>>(obj: T) => NonNullableProperties<NullableKeysToOptional<T>>;
export declare const coerceUndefinedValuesToNull: <T extends Record<string, unknown>>(obj: T) => Record<string, Exclude<T[keyof T], undefined> | null>;
export declare const isArrayOf: <T>(arr: unknown, guard: (v: unknown) => v is T) => arr is T[];
export declare const waitForever: () => Promise<never>;
/**
 * Returns true if only one of the arguments is truthy
 */
export declare const xor: (a: unknown, b: unknown) => boolean;
/**
 * Shortcut for creating string key & value enums. Native TS Enums are problematic in many ways
 * (transform code, instead of just adding types; you cant put a string literal matching the enum value
 * in a variable typed as the enum, etc.)
 */
export declare const StringEnum: <T extends string>(args: T[]) => Readonly<{ [K in T]: K; }>;
/**
 * Shortcut for (typeof StringEnum)[keyof typeof StringEnum]
 */
export type StringEnumValues<T extends Record<string, string>> = {
    [K in keyof T]: T[K] extends string ? T[K] : never;
}[keyof T];
/**
 * Get first non-undefined/null value, or undefined if none found
 */
export declare const firstDefinedValue: <T>(...args: (T | undefined | null)[]) => T | undefined;
//# sourceMappingURL=utility.d.ts.map