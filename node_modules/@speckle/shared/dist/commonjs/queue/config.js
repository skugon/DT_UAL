"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getActiveQueues = exports.initializeQueue = void 0;
const bull_1 = __importDefault(require("bull"));
const ioredis_1 = require("ioredis");
const isRedisReady_js_1 = require("../redis/isRedisReady.js");
// we're caching this here, so that there is one client for the app lifecycle
const clientCache = {};
// so we can get all active queues for monitoring
const queueCache = {};
const initializeQueue = async ({ queueName, redisUrl, options }) => {
    if (!(redisUrl in clientCache))
        clientCache[redisUrl] = {};
    const opts = {
        ...options,
        // redisOpts here will contain at least a property of connectionName which will identify the queue based on its name
        createClient(type, redisOpts) {
            switch (type) {
                case 'client':
                    if (redisUrl in clientCache && clientCache[redisUrl].client !== undefined) {
                        return clientCache[redisUrl].client;
                    }
                    else {
                        const client = new ioredis_1.Redis(redisUrl, redisOpts ?? {});
                        clientCache[redisUrl].client = client;
                        return client;
                    }
                case 'subscriber':
                    if (redisUrl in clientCache &&
                        clientCache[redisUrl].subscriber !== undefined) {
                        return clientCache[redisUrl].subscriber;
                    }
                    else {
                        const subscriber = new ioredis_1.Redis(redisUrl, {
                            ...redisOpts,
                            maxRetriesPerRequest: null,
                            enableReadyCheck: false
                        });
                        clientCache[redisUrl].subscriber = subscriber;
                        return subscriber;
                    }
                case 'bclient':
                    return new ioredis_1.Redis(redisUrl, {
                        ...redisOpts,
                        maxRetriesPerRequest: null,
                        enableReadyCheck: false
                    });
                default:
                    throw new Error(`Unexpected connection type: ${type}`);
            }
        }
    };
    const newQueue = new bull_1.default(queueName, opts);
    queueCache[queueName] = newQueue;
    // When newQueue closed, remove from cache
    newQueue.on('close', () => {
        delete queueCache[queueName];
    });
    newQueue.client.on('end', () => {
        delete queueCache[queueName];
    });
    if (!clientCache[redisUrl].client)
        throw new Error('Redis client not properly initialized');
    await (0, isRedisReady_js_1.isRedisReady)(clientCache[redisUrl].client);
    return await newQueue.isReady();
};
exports.initializeQueue = initializeQueue;
const getActiveQueues = () => ({ ...queueCache });
exports.getActiveQueues = getActiveQueues;
//# sourceMappingURL=config.js.map